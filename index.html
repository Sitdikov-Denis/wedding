<!doctype html>
<html lang="ru">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Колба голосов — 3D (полировка)</title>
<style>
  :root{
    --bg:#efe2cf; --bg2:#f5eadb; --gold:#c8a767; --blue:#5bb3ff; --pink:#ff7fb2;
    --text:#3b2b1f; --muted:#8f7f6f;
  }
  *{box-sizing:border-box}
  html,body{height:100%;margin:0;background:radial-gradient(1200px 700px at 50% 0%, var(--bg2), var(--bg));font-family:system-ui,-apple-system,Segoe UI,Roboto;color:var(--text)}
  .wrap{min-height:100%;display:grid;grid-template-rows:auto auto 1fr;gap:10px;padding:10px}
  header{display:flex;gap:10px;justify-content:center;align-items:center;flex-wrap:wrap}
  .pill{padding:8px 12px;border:1px solid #d9c9aa;border-radius:999px;background:#fff8ee;box-shadow:0 2px 8px #0000000d,inset 0 1px 0 #ffffff80;font-weight:800}
  .pill .dot{display:inline-block;width:10px;height:10px;border-radius:50%;margin-right:8px;vertical-align:middle}
  .pill.b .dot{background:var(--blue)} .pill.p .dot{background:var(--pink)}

  .stage{display:grid;grid-template-columns:minmax(140px,16vw) 1fr minmax(140px,16vw);align-items:center;gap:14px}
  .counter{display:flex;flex-direction:column;align-items:center;gap:6px}
  .label{padding:6px 12px;border:1px solid #d9c9aa;border-radius:14px;background:#fff8ee;font-weight:900;letter-spacing:.6px}
  .value{font-size:clamp(48px,8vw,138px);line-height:1;font-weight:1000;text-shadow:0 6px 18px #00000022}
  .canvasWrap{position:relative;min-height:64vh;border-radius:26px;background:radial-gradient(1400px 700px at 50% -10%,#ffffff,#ddd);box-shadow:0 18px 50px #00000025, inset 0 1px 0 #ffffffb0;border:1px solid #efe7d8;display:grid;place-items:center;overflow:hidden}
  #three{width:100%;height:70vh;display:block}

  .controls{display:flex;justify-content:flex-end;gap:10px;padding:0 8px}
  .btn{padding:10px 16px;border:1px solid #d9c9aa;border-radius:14px;background:#fff8ee;cursor:pointer;font-weight:900;box-shadow:0 6px 22px #0000001a,inset 0 1px 0 #ffffffb0}
  .btn:active{transform:translateY(1px)}
  .hidden{display:none !important}

  .winner{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;background:radial-gradient(700px 400px at 50% 40%,#ffffff60,#0000);opacity:0;pointer-events:none;transition:opacity .5s ease}
  .winner.show{opacity:1}
  .card{padding:28px 34px;border-radius:22px;background:#fff8eecc;border:1px solid #e6d6b8;box-shadow:0 20px 80px #00000040;text-align:center}
  .card h1{margin:0 0 6px;font-size:clamp(26px,4vw,48px)}
  .card p{margin:0;color:var(--muted);font-size:clamp(16px,2vw,20px)}
</style>
</head>
<body>
<div class="wrap">

  <header id="topbar">
    <span class="pill b"><span class="dot"></span>Мальчик: <span id="cntBoySmall">0</span></span>
    <span class="pill p"><span class="dot"></span>Девочка: <span id="cntGirlSmall">0</span></span>
    <span class="pill">Итого: <span id="cntTotal">0</span></span>
    <span class="pill" id="scaleInfo">1 шарик = 1 голос</span>
  </header>

  <div class="controls" id="ctrl">
    <button class="btn" id="fsBtn">На весь экран</button>
    <button class="btn" id="goBtn">Поехали</button>
  </div>

  <section class="stage">
    <aside class="counter">
      <div class="label">МАЛЬЧИК</div>
      <div class="value" id="cntBoyBig">0</div>
    </aside>

    <div class="canvasWrap">
      <canvas id="three"></canvas>
      <div class="winner" id="winner">
        <div class="card">
          <h1 id="winTitle">Победитель</h1>
          <p id="winSub">Все голоса учтены</p>
        </div>
      </div>
    </div>

    <aside class="counter">
      <div class="label">ДЕВОЧКА</div>
      <div class="value" id="cntGirlBig">0</div>
    </aside>
  </section>
</div>

<!-- Three.js -->
<script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>
<script src="https://unpkg.com/three@0.160.0/examples/js/controls/OrbitControls.js"></script>
<script>
/*** ===== НАСТРОЙКИ ДАННЫХ ===== ***/
const SOURCE_URL = "https://docs.google.com/spreadsheets/d/e/2PACX-1vScUpoDoG9BZOfEGgNdecule2fc6mVQBYVCMB5JjksJLZD2Pw48jb9G1wqWqmuuBM2XS2p3lxBm3Dj8/pub?gid=1307519951&single=true&output=csv";
const POLL_MS = 2000;

const CAPACITY = 70;           // шариков визуально в банке
const DROP_INTERVAL = 1000;    // шаг падения
const BALL_R = 0.22;           // радиус
const COLS = 10;
const ROW_SPACING = 0.52, COL_SPACING = 0.48;

/*** ===== UI ===== ***/
const fsBtn = document.getElementById('fsBtn');
const goBtn = document.getElementById('goBtn');
const topbar = document.getElementById('topbar');
const ctrl = document.getElementById('ctrl');
const scaleInfo = document.getElementById('scaleInfo');
const cntBoySmall = document.getElementById('cntBoySmall');
const cntGirlSmall= document.getElementById('cntGirlSmall');
const cntTotal = document.getElementById('cntTotal');
const cntBoyBig = document.getElementById('cntBoyBig');
const cntGirlBig= document.getElementById('cntGirlBig');
const winnerEl = document.getElementById('winner');
const winTitle = document.getElementById('winTitle');
const winSub   = document.getElementById('winSub');

let started=false, finishShownFor=-1;

/*** ===== THREE.js СЦЕНА ===== ***/
const canvas = document.getElementById('three');
const renderer = new THREE.WebGLRenderer({canvas, antialias:true, alpha:true});
renderer.setPixelRatio(Math.min(2, window.devicePixelRatio||1));
renderer.setSize(canvas.clientWidth, canvas.clientHeight, false);
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;

const scene = new THREE.Scene();
scene.background = null;

const camera = new THREE.PerspectiveCamera(28, 2, 0.1, 100);
camera.position.set(0, 2.6, 10);
const controls = new THREE.OrbitControls(camera, canvas);
controls.enableDamping = true; controls.enablePan = false; controls.minDistance = 6; controls.maxDistance = 12; controls.target.set(0,1.6,0);

/* HDRI окружение (лёгкое): рисуем тёплую градиентную карту на canvas → PMREM */
function makeWarmEquirect(size=512){
  const c = document.createElement('canvas'); c.width=size; c.height=size/2;
  const ctx = c.getContext('2d');
  const g = ctx.createLinearGradient(0,0,0,c.height);
  g.addColorStop(0,'#fff6e8');
  g.addColorStop(.35,'#f4e6cf');
  g.addColorStop(1,'#e8dbc6');
  ctx.fillStyle=g; ctx.fillRect(0,0,c.width,c.height);

  // мягкие «световые круги»
  for(let i=0;i<3;i++){
    const cx = (0.25 + i*0.3) * c.width,
          cy = (0.35 + (i%2)*0.2) * c.height,
          r  = c.height*0.6;
    const rg = ctx.createRadialGradient(cx,cy,1,cx,cy,r);
    rg.addColorStop(0, 'rgba(255,255,255,0.55)');
    rg.addColorStop(1, 'rgba(255,255,255,0)');
    ctx.fillStyle = rg; ctx.beginPath(); ctx.arc(cx,cy,r,0,Math.PI*2); ctx.fill();
  }
  const tex = new THREE.CanvasTexture(c);
  tex.mapping = THREE.EquirectangularReflectionMapping;
  tex.colorSpace = THREE.SRGBColorSpace;
  return tex;
}
const pmrem = new THREE.PMREMGenerator(renderer);
const envRT = pmrem.fromEquirectangular(makeWarmEquirect());
scene.environment = envRT.texture;

/* Свет */
const hemi = new THREE.HemisphereLight(0xffffff, 0xf0e0cc, 0.55);
scene.add(hemi);
const dir = new THREE.DirectionalLight(0xffffff, 0.9);
dir.position.set(4,6,6);
dir.castShadow = true;
dir.shadow.mapSize.set(1024,1024);
dir.shadow.radius = 4;
dir.shadow.camera.near = 1; dir.shadow.camera.far = 20;
dir.shadow.camera.left = -6; dir.shadow.camera.right = 6;
dir.shadow.camera.top = 6; dir.shadow.camera.bottom = -3;
scene.add(dir);
scene.add(new THREE.AmbientLight(0xffffff, 0.18));

/* Процедурный «мрамор» */
function marbleTexture(w=1024,h=512){
  const c = document.createElement('canvas'); c.width=w; c.height=h;
  const ctx = c.getContext('2d');
  // базовый цвет
  const bg = ctx.createLinearGradient(0,0,0,h);
  bg.addColorStop(0,'#f4ede5'); bg.addColorStop(1,'#efe7dd');
  ctx.fillStyle=bg; ctx.fillRect(0,0,w,h);
  // полупрозрачные прожилки
  ctx.globalAlpha = 0.13; ctx.strokeStyle='#cfc5bb'; ctx.lineWidth=2.2;
  for(let i=0;i<60;i++){
    let x = Math.random()*w, y = Math.random()*h;
    ctx.beginPath();
    ctx.moveTo(x,y);
    for(let k=0;k<6;k++){
      x += (Math.random()*120-60); y += (Math.random()*60-30);
      ctx.lineTo(x,y);
    }
    ctx.stroke();
  }
  // лёгкие пятна
  for(let i=0;i<12;i++){
    const gx = Math.random()*w, gy = Math.random()*h, r = 40+Math.random()*120;
    const g = ctx.createRadialGradient(gx,gy,1,gx,gy,r);
    g.addColorStop(0,'rgba(200,190,180,0.18)');
    g.addColorStop(1,'rgba(200,190,180,0)');
    ctx.fillStyle=g; ctx.beginPath(); ctx.arc(gx,gy,r,0,Math.PI*2); ctx.fill();
  }
  const tex = new THREE.CanvasTexture(c);
  tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
  tex.repeat.set(1,1);
  tex.colorSpace = THREE.SRGBColorSpace;
  return tex;
}

/* Пьедестал */
const pedestal = new THREE.Group();
function addDisk(r,h,y,rough=0.6){
  const geo = new THREE.CylinderGeometry(r,r,h,96,1,true);
  const mat = new THREE.MeshStandardMaterial({
    map: marbleTexture(1024,512), roughness: rough, metalness: 0.0
  });
  const m = new THREE.Mesh(geo, mat); m.position.y=y; m.receiveShadow = true; m.castShadow=false;
  pedestal.add(m);
}
// тени-подложки (мягкий эллипс)
function addShadowEllipse(r, y, alpha){
  const g = new THREE.CircleGeometry(r, 64);
  const m = new THREE.MeshBasicMaterial({transparent:true, opacity:alpha, color:0x000000});
  const disk = new THREE.Mesh(g, m);
  disk.rotation.x = -Math.PI/2; disk.position.y = y;
  disk.material.onBeforeCompile = (shader)=>{
    shader.fragmentShader = shader.fragmentShader.replace(
      `#include <common>`,
      `#include <common>
       float softEdge(vec2 uv){ vec2 c = uv*2.0-1.0; float d = length(c); return smoothstep(1.0, 0.7, d); }`
    ).replace(
      `gl_FragColor = vec4( diffuse, opacity );`,
      `gl_FragColor = vec4(vec3(0.0), opacity*softEdge(gl_PointCoord));`
    );
  };
  pedestal.add(disk);
}
addDisk(3.2,0.18,0.09,0.65);
addDisk(2.9,0.18,0.27,0.62);
addDisk(2.5,0.24,0.48,0.58);
addShadowEllipse(3.2,0.05,0.15);
scene.add(pedestal);

/* Банка (стекло) — сглаженный профиль + «золотой» кант */
function makeJar(){
  const pts = [];
  pts.push(new THREE.Vector2(1.10, 0.52));
  pts.push(new THREE.Vector2(1.07, 0.72));
  pts.push(new THREE.Vector2(0.98, 1.55));
  pts.push(new THREE.Vector2(0.88, 2.18));
  pts.push(new THREE.Vector2(0.82, 2.52));
  const lathe = new THREE.LatheGeometry(pts, 120);
  const glass = new THREE.MeshPhysicalMaterial({
    color: 0xffffff, roughness: 0.05, metalness: 0.0,
    transmission: 0.98, thickness: 0.26, ior: 1.46, clearcoat: 1, clearcoatRoughness: 0.05,
    envMapIntensity: 1.0
  });
  const jar = new THREE.Mesh(lathe, glass); jar.castShadow=false; jar.receiveShadow=false;

  const ringGeo = new THREE.TorusGeometry(0.83, 0.06, 32, 100);
  const ringMat = new THREE.MeshStandardMaterial({color:0xc7a66a, metalness:1.0, roughness:0.24, envMapIntensity:1.0});
  const ring = new THREE.Mesh(ringGeo, ringMat);
  ring.rotation.x = Math.PI/2; ring.position.y = 2.60; ring.castShadow=true;

  const neckGeo = new THREE.CylinderGeometry(0.76,0.76,0.10,64,1,true);
  const neck = new THREE.Mesh(neckGeo, glass.clone());
  neck.position.y = 2.55;

  const g = new THREE.Group();
  g.add(jar, ring, neck);
  return g;
}
const jar = makeJar();
scene.add(jar);

/* Клиппинг-область укладки шаров */
const clipRadius = 0.82;
const clipTopY  = 2.25;

/* Группа шаров */
const ballsGroup = new THREE.Group(); scene.add(ballsGroup);

/* Материалы шаров */
const matBoy  = new THREE.MeshPhysicalMaterial({color:0x57a9ff, roughness:0.28, metalness:0.0, clearcoat:1, clearcoatRoughness:0.18, envMapIntensity:1.0});
const matGirl = new THREE.MeshPhysicalMaterial({color:0xff6fae, roughness:0.28, metalness:0.0, clearcoat:1, clearcoatRoughness:0.18, envMapIntensity:1.0});
const ballGeo = new THREE.SphereGeometry(BALL_R, 48, 32);

/* сетка позиций (как «аккуратная укладка») */
function targetPositionForIndex(idx){
  const row = Math.floor(idx / COLS);
  const col = idx % COLS;
  const x = (col - (COLS-1)/2) * COL_SPACING * 0.9;
  const y = 0.52 + BALL_R + row * ROW_SPACING;
  const z = 0;
  return {x,y,z};
}

/* падение шарика с лёгким «пружинящим» easing */
function spawnBall(color, idx){
  const mesh = new THREE.Mesh(ballGeo, color==='boy'?matBoy:matGirl);
  const t = targetPositionForIndex(idx);
  mesh.position.set( (Math.random()-0.5)*0.4, clipTopY + 0.5 + Math.random()*0.5, (Math.random()-0.5)*0.4 );
  mesh.castShadow = true; mesh.receiveShadow=false;
  ballsGroup.add(mesh);

  const start = performance.now(), dur = 900;
  function step(){
    const k = Math.min(1, (performance.now()-start)/dur);
    const e = k<1 ? 1 - Math.pow(1-k, 3) : 1; // easeOutCubic
    mesh.position.x = THREE.MathUtils.lerp(mesh.position.x, t.x, e);
    mesh.position.y = THREE.MathUtils.lerp(mesh.position.y, t.y, e);
    mesh.position.z = THREE.MathUtils.lerp(mesh.position.z, t.z, e);
    if (k<1) requestAnimationFrame(step);
  }
  requestAnimationFrame(step);
}

/*** ===== ДАННЫЕ / СЧЁТ ===== ***/
let serverSeq = [];      // ['boy','girl',...]
let animatedN = 0;       // сколько визуально уронили
let score = {boy:0, girl:0};

function updateScoreUI(){
  cntBoySmall.textContent = score.boy; cntBoyBig.textContent = score.boy;
  cntGirlSmall.textContent= score.girl; cntGirlBig.textContent= score.girl;
  cntTotal.textContent = score.boy + score.girl;
  const scale = Math.max(1, Math.ceil((serverSeq.length||1)/CAPACITY));
  scaleInfo.textContent = `1 шарик = ${scale} голос${pluralRu(scale,['','а','ов'])}`;
}
function pluralRu(n, forms){ const n10=n%10,n100=n%100; if(n10===1&&n100!==11)return forms[0]; if(n10>=2&&n10<=4&&(n100<10||n100>=20))return forms[1]; return forms[2]; }

function normalizeChoice(v){
  const s = (v||"").toLowerCase();
  if (s.includes("маль")||s.includes("boy")||s.includes("голуб")) return "boy";
  if (s.includes("дев") ||s.includes("girl")||s.includes("розов")) return "girl";
  return "";
}
function parseCsv(text){
  const rows=[]; let row=[],cur="",inQ=false;
  for(let i=0;i<text.length;i++){
    const c=text[i], n=text[i+1];
    if(c=='"'){ if(inQ && n=='"'){cur+='"'; i++;} else inQ=!inQ; }
    else if(c==',' && !inQ){row.push(cur); cur="";}
    else if((c=='\n'||c=='\r') && !inQ){ if(cur!==""||row.length){row.push(cur); rows.push(row); row=[]; cur="";} }
    else cur+=c;
  }
  if(cur!==""||row.length){row.push(cur); rows.push(row);}
  return rows;
}

async function fetchSeq(){
  const url = SOURCE_URL + (SOURCE_URL.includes('?')?'&':'?') + 'nocache=' + Date.now();
  const res = await fetch(url, {cache:'no-store'}).catch(()=>null);
  if(!res||!res.ok) return;
  const text = await res.text();
  const rows = parseCsv(text).filter(r=>r.length>=2);
  const seq = [];
  for(let i=1;i<rows.length;i++){
    const norm = normalizeChoice((rows[i][1]||"").trim());
    if(norm) seq.push(norm);
  }
  serverSeq = seq;
  const scale = Math.max(1, Math.ceil((serverSeq.length||1)/CAPACITY));
  scaleInfo.textContent = `1 шарик = ${scale} голос${pluralRu(scale,['','а','ов'])}`;
  if (finishShownFor>=0 && (score.boy+score.girl)<serverSeq.length) hideWinner();
}

function animateNew(fromIdx){
  const batch = serverSeq.slice(fromIdx, Math.min(serverSeq.length, CAPACITY));
  batch.forEach((c, i)=>{
    setTimeout(()=>{
      spawnBall(c, fromIdx+i);
      if (c==='boy') score.boy++; else score.girl++;
      updateScoreUI(); checkFinish();
    }, i*DROP_INTERVAL);
  });
  animatedN = Math.min(serverSeq.length, CAPACITY);

  const extra = serverSeq.slice(CAPACITY);
  extra.forEach((c, j)=>{
    setTimeout(()=>{
      if (c==='boy') score.boy++; else score.girl++;
      updateScoreUI(); checkFinish();
    }, (batch.length + j)*DROP_INTERVAL);
  });
}

function checkFinish(){
  if(!started) return;
  const totalNow = score.boy + score.girl;
  if(totalNow < serverSeq.length) return;
  if(finishShownFor === serverSeq.length) return;

  if(score.boy>score.girl){ showWinner('Победил МАЛЬЧИК!', 'Поздравляем родителей!'); }
  else if(score.girl>score.boy){ showWinner('Победила ДЕВОЧКА!', 'Поздравляем родителей!'); }
  else { showWinner('Ничья!', 'Вы — идеальная команда ♥'); }
  finishShownFor = serverSeq.length;
}
function showWinner(title, sub){ winTitle.textContent=title; winSub.textContent=sub; winnerEl.classList.add('show'); }
function hideWinner(){ winnerEl.classList.remove('show'); }

/*** ===== СТАРТ / ФУЛЛСКРИН ===== ***/
fsBtn.onclick = async()=>{
  try{ await document.documentElement.requestFullscreen(); }catch(e){}
  fsBtn.classList.add('hidden');
};
goBtn.onclick = async()=>{
  if(started) return;
  started = true;
  topbar.classList.add('hidden'); ctrl.classList.add('hidden');
  try{ if(!document.fullscreenElement) await document.documentElement.requestFullscreen(); }catch(e){}
  while(ballsGroup.children.length) ballsGroup.remove(ballsGroup.children[0]);
  score={boy:0,girl:0}; animatedN=0; finishShownFor=-1; hideWinner(); updateScoreUI();
  animateNew(0);
};

/*** ===== РЕСАЙЗ/РЕНДЕР ===== ***/
function resizeRendererToDisplaySize(){
  const c = renderer.domElement;
  const width = c.clientWidth, height = c.clientHeight;
  if(c.width !== width || c.height !== height){
    renderer.setSize(width, height, false);
    camera.aspect = width/height; camera.updateProjectionMatrix();
  }
}
function render(){
  resizeRendererToDisplaySize();
  controls.update();
  renderer.render(scene, camera);
  requestAnimationFrame(render);
}
requestAnimationFrame(render);
window.addEventListener('resize', ()=>resizeRendererToDisplaySize());

/*** ===== ПУЛЛИНГ ДАННЫХ ===== ***/
fetchSeq(); setInterval(fetchSeq, POLL_MS);
</script>
</body>
</html>
